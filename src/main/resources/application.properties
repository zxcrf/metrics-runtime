# Quarkus Application Configuration
# 升级到 Quarkus 3.12.3 + JDK 21 虚拟线程 + DuckDB Parquet 优化

# Application Info
quarkus.application.name=dataos-metrics-runtime
quarkus.http.port=8080
quarkus.http.host=0.0.0.0

# Virtual Threads
quarkus.virtual-threads.enabled=true

# MetaDB (MySQL)
quarkus.datasource.metadb.db-kind=${DATAOS_METRICS_METADB_TYPE:mysql}
quarkus.datasource.metadb.jdbc.url=${DATAOS_METRICS_METADB_JDBC_URL:jdbc:mysql://127.0.0.1:3306/kpi_2025?useSSL=FALSE&characterEncoding=utf-8&allowPublicKeyRetrieval=true&allowMultiQueries=true}
quarkus.datasource.metadb.username=${DATAOS_METRICS_METADB_USERNAME:root}
quarkus.datasource.metadb.password=${DATAOS_METRICS_METADB_PASSWORD:root}
# 增大连接池以支持高并发压测（wrk -c100 需要至少 100+ 连接）
quarkus.datasource.metadb.jdbc.max-size=${DATAOS_METRICS_METADB_MAX_SIZE:150}
quarkus.datasource.metadb.jdbc.min-size=10
# 延长获取连接超时时间，高并发时避免过早失败
quarkus.datasource.metadb.jdbc.acquisition-timeout=10
# 连接最大生命周期 30 分钟，防止 MySQL 服务器关闭长时间空闲连接
quarkus.datasource.metadb.jdbc.max-lifetime=30M
# 空闲连接移除间隔 5 分钟，定期清理无用连接
quarkus.datasource.metadb.jdbc.idle-removal-interval=5M

# MetaDB Pool Optimization
%prod.quarkus.datasource.metadb.jdbc.additional-jdbc-properties.preparedStatementCacheSize=500
%prod.quarkus.datasource.metadb.jdbc.additional-jdbc-properties.preparedStatementCacheSqlLimit=2048
# 缩短 socket 超时到 30 秒，快速失败而不是长时间阻塞
%prod.quarkus.datasource.metadb.jdbc.additional-jdbc-properties.socketTimeout=30
# 验证查询和后台验证间隔
quarkus.datasource.metadb.jdbc.validation-query-sql=SELECT 1
# 缩短后台验证间隔到 30 秒，更频繁地检测失效连接
quarkus.datasource.metadb.jdbc.background-validation-interval=30S

# DuckDB DataSource Configuration (核心引擎)
quarkus.datasource.duckdb.db-kind=other
quarkus.datasource.duckdb.jdbc.driver=org.duckdb.DuckDBDriver


# ==============================================================================
# 4C/8G 调优配置
# ==============================================================================
# 1. DuckDB 资源限制 (关键)
# threads=4: 限制 DuckDB 内部并行度不超过物理核数，避免抢占 HTTP 线程
# memory_limit=2.5GB: 严格限制 DuckDB 堆外内存，防止容器 OOM
quarkus.datasource.duckdb.jdbc.url=jdbc:duckdb::memory:?threads=4&memory_limit=2.5GB
# 2. 数据库连接池 (限流阀)
# 不需要太大，DuckDB 处理快，积压的请求在虚拟线程里排队即可
# 设置为 16 (CPU * 4)，保证有足够的连接处理并发，但不会撑爆内存
quarkus.datasource.duckdb.jdbc.max-size=16
quarkus.datasource.duckdb.jdbc.min-size=4
quarkus.datasource.duckdb.jdbc.acquisition-timeout=5

# MinIO Configuration
minio.endpoint=${MINIO_ENDPOINT:http://127.0.0.1:9000}
minio.access-key=${MINIO_ACCESS_KEY:minioadmin}
minio.secret-key=${MINIO_SECRET_KEY:minioadmin}
minio.bucket.metrics=${MINIO_BUCKET:metrics-runtime}
minio.secure=false

# MinIO Client Pool Optimization
minio.pool.max-idle=500
minio.http.max-requests=500
minio.http.max-requests-per-host=100
# 保持连接更久一点，减少握手开销
minio.pool.keep-alive-minutes=5
minio.http.read-timeout-sec=5
minio.http.connect-timeout-sec=2

# Redis Configuration
quarkus.redis.hosts=redis://${REDIS_HOST:127.0.0.1}:${REDIS_PORT:6379}
quarkus.redis.password=${REDIS_PASSWORD:}
quarkus.redis.max-pool-size=${REDIS_MAX_POOL_SIZE:128}
quarkus.redis.max-pool-waiting=${REDIS_MAX_POOL_WAITING:2048}

# 根据内存调整，每条目约10-100KB
kpi.cache.max.size=1000
# Cache TTL
kpi.cache.ttl.minutes=${KPI_CACHE_TTL_MINUTES:30}

# Cache Enable/Disable Switches (for performance testing)
# L1: Caffeine memory cache (5s hot cache)
kpi.cache.l1.enabled=${KPI_CACHE_L1_ENABLED:false}
# L2: Redis distributed cache
kpi.cache.l2.enabled=${KPI_CACHE_L2_ENABLED:true}
# L3: Local file existence cache (StorageManager)
kpi.cache.l3.enabled=${KPI_CACHE_L3_ENABLED:true}

# Monitoring
quarkus.micrometer.enabled=true
quarkus.micrometer.export.prometheus.enabled=true
quarkus.micrometer.binder.vertx.enabled=true

# Logging
quarkus.log.console.json.enabled=false

# Engine Config
metrics.engine.type=${DATAOS_METRICS_ENGINE:SQLite}
metrics.driver.plugin.dir=${DATAOS_METRICS_DRIVER_PLUGIN:plugin}
metrics.sqlite.storage.dir=${DATAOS_METRICS_SQLITE_STORAGE_DIR:/tmp/cache}